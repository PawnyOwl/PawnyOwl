use crate::board::Board;
use crate::core::Sq;
use crate::movegen::{MoveGen, MoveList};
use crate::moves::{Move, MoveKind, PackedMove, ValidateError};
use std::str::FromStr;

#[derive(Debug, Eq)]
struct BoardFullEq<'a>(&'a Board);

impl<'a> PartialEq for BoardFullEq<'a> {
    #[inline]
    fn eq(&self, other: &BoardFullEq<'a>) -> bool {
        self.0.r == other.0.r
            && self.0.hash == other.0.hash
            && self.0.white == other.0.white
            && self.0.black == other.0.black
            && self.0.cells == other.0.cells
            && self.0.all_v == other.0.all_v
    }
}

#[inline]
fn test_board_valid(b: &Board) {
    let b_other = b.raw().try_into().unwrap();
    assert_eq!(BoardFullEq(&b_other), BoardFullEq(b));
}

#[inline]
fn move_key(m: &Move) -> (u8, u8, u8) {
    (m.kind() as u8, m.src().index() as u8, m.dst().index() as u8)
}

fn filter_legal_moves(b: &Board, l: &mut MoveList) {
    l.retain(|m| {
        assert!(m.is_well_formed(), "move {} not well-formed", m);
        match m.validate(b) {
            Ok(()) => true,
            Err(ValidateError::NotLegal) => false,
            Err(ValidateError::NotSemiLegal) => panic!("move {} not semi-legal", m),
            Err(ValidateError::NotWellFormed) => unreachable!(),
        }
    });
}

pub fn selftest(b: &Board) {
    // Check that the board itself is valid.
    test_board_valid(b);

    // Check that `to_string()` and `from_str()` are symmetrical.
    let fen = b.to_string();
    let b2 = Board::from_str(&fen).unwrap();
    assert_eq!(BoardFullEq(&b2), BoardFullEq(b));

    // Try to generate moves in total and compare the result if we generate simple moves and captures separately.
    let move_gen = MoveGen::new(b);

    let mut moves = MoveList::new();
    move_gen.gen_all(&mut moves);
    filter_legal_moves(b, &mut moves);

    let mut moves_capture = MoveList::new();
    move_gen.gen_capture(&mut moves_capture);
    filter_legal_moves(b, &mut moves_capture);

    let mut moves_simple = MoveList::new();
    move_gen.gen_simple(&mut moves_simple);
    filter_legal_moves(b, &mut moves_simple);

    let mut moves_simple2 = MoveList::new();
    move_gen.gen_simple_no_promote(&mut moves_simple2);
    move_gen.gen_simple_promote(&mut moves_simple2);
    filter_legal_moves(b, &mut moves_simple2);

    let mut moves2 = MoveList::new();
    moves2.extend(moves_simple.iter().copied());
    moves2.extend(moves_capture.iter().copied());

    moves.sort_by_key(move_key);
    moves2.sort_by_key(move_key);
    moves_simple.sort_by_key(move_key);
    moves_simple2.sort_by_key(move_key);
    assert_eq!(moves, moves2);
    assert_eq!(moves_simple, moves_simple2);

    // Check that move parser works correctly.
    for m in &moves {
        assert_eq!(Move::from_uci(&m.to_string(), b), Ok(*m));
    }

    // Check that any move for which `validate()` returns `Ok(())` is generated by `MoveGen` as well.
    let mut semilegals = MoveList::new();
    let mut moves3 = MoveList::new();
    for kind in MoveKind::iter() {
        for src in Sq::iter() {
            for dst in Sq::iter() {
                if let Ok(mv) = Move::new(kind, src, dst) {
                    if mv.semi_validate(b).is_ok() {
                        semilegals.push(mv);
                        if unsafe { mv.is_legal_unchecked(b) } {
                            moves3.push(mv);
                        }
                    }
                }
            }
        }
    }
    moves3.sort_by_key(move_key);
    assert_eq!(moves, moves3);

    // Check that `is_opponent_king_attacked()` and `is_legal_unchecked()` are identical. Also check that board is valids after making moves.
    let mut b_clone = b.clone();
    for m in &semilegals {
        let is_legal = unsafe { m.is_legal_unchecked(&b_clone) };
        let u = unsafe { b_clone.make_move_unchecked(*m) };
        let is_legal2 = !b_clone.is_opponent_king_attacked();
        assert_eq!(is_legal, is_legal2);
        if is_legal {
            test_board_valid(&b_clone);
        }
        unsafe { b_clone.unmake_move_unchecked(*m, u) };
        assert_eq!(BoardFullEq(&b_clone), BoardFullEq(b));
    }

    // Check that packing moves works correctly.
    for m in &semilegals {
        assert_eq!(Move::from(PackedMove::from(*m)), *m);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::board::Board;

    #[test]
    fn test_simple() {
        selftest(&Board::start());
        selftest(
            &Board::from_str("r1bqk1nr/pppp1ppp/2n5/2b1p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4")
                .unwrap(),
        )
    }
}
